//#-hidden-code
//
//  Contents.swift
//
//  Copyright Â© 2016-2018 Apple Inc. All rights reserved.
//
//#-code-completion(everything, hide)
//#-code-completion(currentmodule, show)
//#-code-completion(literal, show, array, boolean, color, dictionary, image, string)
//#-code-completion(keyword, show, for, func, if, let, var, while)
//#-code-completion(snippet, show, repeat, switch, protocol, enum, struct, class)
//#-code-completion(identifier, hide, _ImageLiteralType)
//#-code-completion(description, hide, "run(block: () -> Void)", "(x: Int, y: Int)", "(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)", "(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat)")
//#-code-completion(identifier, show, allowsTouchInteraction, touchedGraphic, red, green, !=, %, &&, (, (), (configuration:), (hue:saturation:brightness:alpha:), (image:), (image:columns:rows:), (image:columns:rows:isDynamic:name:), (image:name:), (pitch:volume:), (red:green:blue:alpha:), (shape:color:), (shape:color:gradientColor:name:), (text:color:), (text:color:font:size:name:), (type:), (type:name:), (type:text:name:), (width:height:), (x:y:), ), *, +, +=, -, -=, ., ..., ..<, /, <, <=, =, ==, >, >=, A1, A2, A3, A4, A5, AS1, AS2, AS3, AS4, AS5, AcademyEngravedLET, Action, AmericanTypewriter, AnchorPoint, Animation, AppleSDGothicNeo, Arial, ArialRoundedMTBold, Array, Avenir, AvenirNext, AvenirNextCondensed, B1, B2, B3, B4, B5, Baskerville, Bodoni72, BradleyHand, Button, ButtonType, C1, C2, C3, C4, C5, CS1, CS2, CS3, CS4, CS5, ChalkDuster, ChalkboardSE, Cochin, Collision, Color, Copperplate, Courier, CourierNew, D1, D2, D3, D4, D5, DS1, DS2, DS3, DS4, DS5, Didot, E1, E2, E3, E4, E5, F1, F2, F3, F4, F5, FS1, FS2, FS3, FS4, FS5, Font, Futura, G1, G2, G3, G4, G5, GS1, GS2, GS3, GS4, GS5, Georgia, GillSans, Graphic, Helvetica, HelveticaNeue, HiraginoMinchoProN, HiraginoSans, Impact, Instrument, Kind, Label, LightSensor, MarkerFelt, Menlo, Music, MusicNote, Noteworthy, Optima, Palatino, Papyrus, PartyLET, PingFangSC, PingFangTC, Player, PlayerAnimation, PlayerType, Point, SavoyeLET, Scene, Shape, Size, SnellRoundhand, Sound, Sprite, String, Superclarendon, SystemBoldItalic, SystemFontBlack, SystemFontBold, SystemFontHeavy, SystemFontLight, SystemFontMedium, SystemFontRegular, SystemFontSemibold, SystemFontThin, SystemFontUltraLight, SystemHeavyItalic, SystemItalic, Thonburi, Timer, TimesNewRoman, Tone, ToneOutput, ToneOutput(), ToneSensor, ToneSensor(), Touch, TrebuchetMS, Verdana, Zapfino, addProduct(_:_:), alien, allowsRotation, alpha, angle, append(_:), applyForce(x:y:duration:), applyImpulse(x:y:), aroundTheCorner, audioPlayAction(fileNamed:), back, backgroundColor, backgroundImage, balloon1Pop, balloon2Pop, bassBomb, bassGuitar, bassSynth, blueComponent, boing1, boing2, boing3, bombExplode, bombIdle, boop1, boop2, boop3, bottom, bounce1, bounce2, bounce3, bounciness, brightness, buttonPress1, buttonPress2, buttonType, center, characterType, circle(radius:), circlePoints(radius:count:), clang, clear(), clunk, codeMachine, compactMap(_:), configuration:, containing:, contains(_:), contains(where:), count, crash, createSprites(from:named:), crystalSynth, currentSample, dash(speed:), defeat, distance(from:), distance(from:to:), duck, duck(duration:), dx, dy, electricBeep1, electricBeep2, electricBeep3, electricBeep4, electricBeepFader, electricGuitar, elephant, endIndex, enumerated(), explode, fadeAlpha(by:duration:), fadeAlpha(to:duration:), fadeIn(after:), fadeIn(withDuration:), fadeOut(after:), fadeOut(withDuration:), false, fightForAmericas, filter(_:), first, first(_:), first(where:), firstIndex(of:), firstTouch, fit(within:), flatMap(_:), font, fontSize, forEach(_:), force, formIntersection(_:), formUnion(_:), friendlyPassage, front, getGraphics(at:in:), getGraphics(named:), getGraphicsWithName(containing:), giraffe, graphics, greenComponent, greenButton, gridPoints(size:count:angle:), group(_:), hasCollisionBorder, hasPrefix(_:), hasSuffix(_:), height, helicopterWhoosh, hide(), horizontalGravity, hue, hue:saturation:brightness:alpha:, idle, image, image(text:), image:, image:columns:rows:, image:columns:rows:isDynamic:name:, image:name:, index(_:offsetBy:), index(_:offsetBy:limitedBy:), index(after:), index(before:), index(forKey:), index(of:), insert(_:), insert(_:at:), intersection(_:), isAffectedByGravity, isDisjoint(with:), isDynamic, isEmpty, isGridVisible, isSubset(of:), isSuperset(of:), isZero, joined(), joined(separator:), jump, jump(x:y:), keys, laser1, laser2, laser3, last, left, lessChallenge, lowercased(), machineGreeting1, machineGreeting2, machineGreeting3, magnitude, map(_:), max(), maximum(_:_:), maximumMagnitude(_:_:), medium, min(), minimum(_:_:), minimumMagnitude(_:_:), moreChallenge, move(to:duration:), moveBy(x:y:duration:), name, negate(), onCollisionHandler, onFingerMovedHandler, onGraphicTouchedHandler, orbit(x:y:period:), orbitAction(x:y:period:), overlaid(with:offsetBy:), pageDifficulty, pi, piano, piranha, pitch, pitch:volume:, place(_:at:), place(_:at:anchoredTo:), place(at:), play(tone:), play(tones:), playInstrument(_:note:volume:), playMusic(_:volume:), playSound(_:volume:), pleasantDing1, pleasantDing2, pleasantDing3, polygon(radius:sides:), pop1, pop2, popLast(), position, powerUp1, powerUp2, powerUp3, powerUp4, previousPlaceDistance, pulsate(), pulsate(period:count:), puzzleJam, randomCharacter, randomDouble(from:to:), randomElement(), randomIndex, randomInt(from:to:), randomItem, rectangle(width:height:cornerRadius:), redComponent, red:green:blue:alpha:, redButton, reduce(_:_:), remainder(dividingBy:), remove(), remove(_:), remove(at:), removeAction(forKey:), removeAllActions(), removeFirst(), removeGraphics(named:), removeLast(), removeValue(forKey:), repeat(_:count:), repeatForever(_:), resize(byWidth:height:duration:), resize(toHeight:duration:), resize(toWidth:duration:), resize(toWidth:height:duration), retroBass, retroCollide1, retroCollide2, retroCollide3, retroCollide4, retroCollide5, retroJump1, retroJump2, retroPowerUp1, retroPowerUp2, retroTwang1, retroTwang2, reverse(), reversed(), right, rotate(byAngle:duration:), rotate(toAngle:duration:), rotation, round(), rounded(), rox2TheBox, run(_:), run(_:key:), runAnimation(_:timePerFrame:numberOfTimes:), saturation, scale, scale(by:duration:), scale(to:duration:), scaleX(by:y:duration:), scaleX(to:y:duration:), scaledImage(size:), scheduledTimer(withTimeInterval:repeats:block:), sequence(_:), setOnCollisionHandler(_:), setOnFingerMovedHandler(_:), setOnTapHandler(_:), setOnUpdateHandler(_:), setVelocity(x:y:), sevenSynth, shake(duration:), shape:color:, shape:color:gradientColor:name:, shuffle(), shuffled(), sign, simSationalSmile, size, somethingBad1, somethingBad2, somethingBad3, somethingBad4, somethingGood1, somethingGood2, somethingGood3, somethingGood4, somethingGood5, somethingGood6, somethingGood7, sort(), sort(by:), sorted(), sorted(by:), southAMPitches, speak(_:voice:), speed(by:duration:), speed(to:duration:), spin(period:), splat1, split(separator:), spring1, spring2, spring3, spring4, springExtend, spriteA, spriteB, squarePoints(width:count:), squareRoot(), star(radius:points:sharpness:), start(), startIndex, starts(with:), stop(), stopSpeaking(), stopTones(), strangeWobble, string(fractionDigits:), subtract(_:), swapAt(_:_:), switch1, switch2, text, text:, text:color:, text:color:font:size:name:, textColor, throwSwitchLeft, throwSwitchRight, thud, tone, top, touchHandler, tree1Idle, tree2Idle, true, truncatingRemainder(dividingBy:), tubeHit1, tubeHit2, tubeHit3, type:, type:name:, type:text:name:, unhide(), union(_:), update(with:), updateValue(_:forKey:), uppercased(), values, verticalGravity, victory1, victory2, victory3, victory4, volume, wait(forDuration:), wait(forDuration:withRange:), walk, warble, warmBells, watchEverythingFall, width, width:height:, x, x:y:, x:y:duration:, xScale, y, yScale, {, {}, ||, }, ~=, Image, (with:), with:, uiImage)

import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true
//#-end-hidden-code
//#-editable-code
import UIKit

// Set up the scene.
let scene = Scene()
scene.backgroundImage = #imageLiteral(resourceName: "background6.png")
let floor = Sprite(image: #imageLiteral(resourceName: "floor2"), columns: 20, rows: 1, name: "floor")
let platform = Sprite(image: #imageLiteral(resourceName: "platform3"), columns: 20, rows: 1, name: "ceiling")
scene.place(floor, at: Point(x: 0, y: -475))
scene.place(platform, at: Point(x: 0, y: 505))
scene.verticalGravity = -5.0

// Create some game variables and a distance label.
var gamePlaying = true
var distance = 0.0
let distanceLabel = Label(text: "Distance: 0.0m", color: .white, font: Font.SystemFontHeavy, size: 40, name: "distance")
let labelBackground = Graphic(shape: .rectangle(width: 375, height: 75, cornerRadius: 20), color: #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0))
labelBackground.alpha = 0.3
scene.place(labelBackground, at: Point(x: 0, y: 430))
scene.place(distanceLabel, at: Point(x: 0, y: 430))

// Track how far (the distance) the fish has traveled.
let distanceTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: { _ in
    distance += 0.1
    distanceLabel.text = "Distance: " + distance.string(fractionDigits: 1) + "m"
})

// Create the fish player.
let fish = Player(type: .piranha, name: "fish")
var fishJumping = false
fish.isAffectedByGravity = true
fish.allowsRotation = true
fish.scale = 1.3
scene.place(fish, at: Point(x: -300, y: -200))
fish.applyImpulse(x: 0, y: 450)
fish.runAnimation(.walk, numberOfTimes: -1)

// Create a ToneSensor to make the fish jump when a loud noise is detected.
let toneSensor = ToneSensor()
toneSensor.setOnUpdateHandler( { tone in 
    if tone.volume > 0.25 && !fishJumping {
        fishJumping = true
        fish.jump(x: 0, y: 275)
        playSound(Sound.boop2, volume: 30)
        // Reset fishJumping to false after the jump is complete.
        Timer.scheduledTimer(withTimeInterval: 0.4, repeats: false, block: { _ in
            fishJumping = false
        })
    }
})

// Generate an obstacle and move it across the scene; then remove the obstacle.
let possibleSprites: [Image] = [#imageLiteral(resourceName: "spikes4.png"),#imageLiteral(resourceName: "spikes3.png")]
func generateObstacle() {
    let obstacle = Sprite(image: possibleSprites[randomInt(from: 0, to: 1)], name: "obstacle")
    obstacle.scale = randomDouble(from: 2, to: 5)
    scene.place(obstacle, at: Point(x: 600, y: randomInt(from: -400, to: 400)))
    obstacle.moveBy(x: -1200, y: 0, duration: 3)
    Timer.scheduledTimer(withTimeInterval: 3, repeats: false, block: { _ in
        scene.remove(obstacle)
    })
}

// Call generateObstacle() every 2 seconds.
Timer.scheduledTimer(withTimeInterval: 2, repeats: true, block: { _ in 
    generateObstacle()
})

// Determine what happens when you lose the game.
func loseGame() {
    if gamePlaying {
        distanceTimer.invalidate()
        gamePlaying = false
        toneSensor.stop()
        playSound(Sound.somethingBad2, volume: 40)
        let loseText = Label(text: "Try again!", color: .white, font: Font.SystemHeavyItalic, size: 75)
        scene.place(loseText, at: Point(x: 0, y: 0))
        loseText.pulsate()
    }
}

// Lose the game if a fish collides with the floor or an obstacle.
scene.setOnCollisionHandler( { collision in 
    let names = [collision.spriteA.name, collision.spriteB.name]
    
    if names.contains("fish") && names.contains("obstacle") {
        loseGame()
    }
    if names.contains("fish") && names.contains("floor") {
        loseGame()
    }
})
//#-end-editable-code
//#-hidden-code
//#-end-hidden-code
