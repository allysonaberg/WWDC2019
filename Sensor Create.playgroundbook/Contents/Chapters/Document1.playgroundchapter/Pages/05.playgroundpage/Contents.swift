//#-hidden-code
//
//  Contents.swift
//
//  Copyright © 2016-2018 Apple Inc. All rights reserved.
//
//#-code-completion(everything, hide)
//#-code-completion(currentmodule, show)
//#-code-completion(literal, show, array, boolean, color, dictionary, image, string)
//#-code-completion(keyword, show, for, func, if, let, var, while)
//#-code-completion(snippet, show, repeat, switch, protocol, enum, struct, class)
//#-code-completion(identifier, hide, _ImageLiteralType)
//#-code-completion(description, hide, "run(block: () -> Void)", "(x: Int, y: Int)", "(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)", "(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat)")
//#-code-completion(identifier, show, allowsTouchInteraction , touchedGraphic, red, green, !=, %, &&, (, (), (configuration:), (hue:saturation:brightness:alpha:), (image:), (image:columns:rows:), (image:columns:rows:isDynamic:name:), (image:name:), (pitch:volume:), (red:green:blue:alpha:), (shape:color:), (shape:color:gradientColor:name:), (text:color:), (text:color:font:size:name:), (type:), (type:name:), (type:text:name:), (width:height:), (x:y:), ), *, +, +=, -, -=, ., ..., ..<, /, <, <=, =, ==, >, >=, A1, A2, A3, A4, A5, AS1, AS2, AS3, AS4, AS5, AcademyEngravedLET, Action, AmericanTypewriter, AnchorPoint, Animation, AppleSDGothicNeo, Arial, ArialRoundedMTBold, Array, Avenir, AvenirNext, AvenirNextCondensed, B1, B2, B3, B4, B5, Baskerville, Bodoni72, BradleyHand, Button, ButtonType, C1, C2, C3, C4, C5, CS1, CS2, CS3, CS4, CS5, ChalkDuster, ChalkboardSE, Cochin, Collision, Color, Copperplate, Courier, CourierNew, D1, D2, D3, D4, D5, DS1, DS2, DS3, DS4, DS5, Didot, E1, E2, E3, E4, E5, F1, F2, F3, F4, F5, FS1, FS2, FS3, FS4, FS5, Font, Futura, G1, G2, G3, G4, G5, GS1, GS2, GS3, GS4, GS5, Georgia, GillSans, Graphic, Helvetica, HelveticaNeue, HiraginoMinchoProN, HiraginoSans, Impact, Instrument, Kind, Label, LightSensor, MarkerFelt, Menlo, Music, MusicNote, Noteworthy, Optima, Palatino, Papyrus, PartyLET, PingFangSC, PingFangTC, Player, PlayerAnimation, PlayerType, Point, SavoyeLET, Scene, Shape, Size, SnellRoundhand, Sound, Sprite, String, Superclarendon, SystemBoldItalic, SystemFontBlack, SystemFontBold, SystemFontHeavy, SystemFontLight, SystemFontMedium, SystemFontRegular, SystemFontSemibold, SystemFontThin, SystemFontUltraLight, SystemHeavyItalic, SystemItalic, Thonburi, Timer, TimesNewRoman, Tone, ToneOutput, ToneOutput(), ToneSensor, ToneSensor(), Touch, TrebuchetMS, Verdana, Zapfino, addProduct(_:_:), alien, allowsRotation, alpha, angle, append(_:), applyForce(x:y:duration:), applyImpulse(x:y:), aroundTheCorner, audioPlayAction(fileNamed:), back, backgroundColor, backgroundImage, balloon1Pop, balloon2Pop, bassBomb, bassGuitar, bassSynth, blueComponent, boing1, boing2, boing3, bombExplode, bombIdle, boop1, boop2, boop3, bottom, bounce1, bounce2, bounce3, bounciness, brightness, buttonPress1, buttonPress2, buttonType, center, characterType, circle(radius:), circlePoints(radius:count:), clang, clear(), clunk, codeMachine, compactMap(_:), configuration:, containing:, contains(_:), contains(where:), count, crash, createSprites(from:named:), crystalSynth, currentSample, dash(speed:), defeat, distance(from:), distance(from:to:), duck, duck(duration:), dx, dy, electricBeep1, electricBeep2, electricBeep3, electricBeep4, electricBeepFader, electricGuitar, elephant, endIndex, enumerated(), explode, fadeAlpha(by:duration:), fadeAlpha(to:duration:), fadeIn(after:), fadeIn(withDuration:), fadeOut(after:), fadeOut(withDuration:), false, fightForAmericas, filter(_:), first, first(_:), first(where:), firstIndex(of:), firstTouch, fit(within:), flatMap(_:), font, fontSize, forEach(_:), force, formIntersection(_:), formUnion(_:), friendlyPassage, front, getGraphics(at:in:), getGraphics(named:), getGraphicsWithName(containing:), giraffe, graphics, greenComponent, greenButton, gridPoints(size:count:angle:), group(_:), hasCollisionBorder, hasPrefix(_:), hasSuffix(_:), height, helicopterWhoosh, hide(), horizontalGravity, hue, hue:saturation:brightness:alpha:, idle, image, image(text:), image:, image:columns:rows:, image:columns:rows:isDynamic:name:, image:name:, index(_:offsetBy:), index(_:offsetBy:limitedBy:), index(after:), index(before:), index(forKey:), index(of:), insert(_:), insert(_:at:), intersection(_:), isAffectedByGravity, isDisjoint(with:), isDynamic, isEmpty, isGridVisible, isSubset(of:), isSuperset(of:), isZero, joined(), joined(separator:), jump, jump(x:y:), keys, laser1, laser2, laser3, last, left, lessChallenge, lowercased(), machineGreeting1, machineGreeting2, machineGreeting3, magnitude, map(_:), max(), maximum(_:_:), maximumMagnitude(_:_:), medium, min(), minimum(_:_:), minimumMagnitude(_:_:), moreChallenge, move(to:duration:), moveBy(x:y:duration:), name, negate(), onCollisionHandler, onFingerMovedHandler, onGraphicTouchedHandler, orbit(x:y:period:), orbitAction(x:y:period:), overlaid(with:offsetBy:), pageDifficulty, pi, piano, piranha, pitch, pitch:volume:, place(_:at:), place(_:at:anchoredTo:), place(at:), play(tone:), play(tones:), playInstrument(_:note:volume:), playMusic(_:volume:), playSound(_:volume:), pleasantDing1, pleasantDing2, pleasantDing3, polygon(radius:sides:), pop1, pop2, popLast(), position, powerUp1, powerUp2, powerUp3, powerUp4, previousPlaceDistance, pulsate(), pulsate(period:count:), puzzleJam, randomCharacter, randomDouble(from:to:), randomElement(), randomIndex, randomInt(from:to:), randomItem, rectangle(width:height:cornerRadius:), redComponent, red:green:blue:alpha:, redButton, reduce(_:_:), remainder(dividingBy:), remove(), remove(_:), remove(at:), removeAction(forKey:), removeAllActions(), removeFirst(), removeGraphics(named:), removeLast(), removeValue(forKey:), repeat(_:count:), repeatForever(_:), resize(byWidth:height:duration:), resize(toHeight:duration:), resize(toWidth:duration:), resize(toWidth:height:duration), retroBass, retroCollide1, retroCollide2, retroCollide3, retroCollide4, retroCollide5, retroJump1, retroJump2, retroPowerUp1, retroPowerUp2, retroTwang1, retroTwang2, reverse(), reversed(), right, rotate(byAngle:duration:), rotate(toAngle:duration:), rotation, round(), rounded(), rox2TheBox, run(_:), run(_:key:), runAnimation(_:timePerFrame:numberOfTimes:), saturation, scale, scale(by:duration:), scale(to:duration:), scaleX(by:y:duration:), scaleX(to:y:duration:), scaledImage(size:), scheduledTimer(withTimeInterval:repeats:block:), sequence(_:), setOnCollisionHandler(_:), setOnFingerMovedHandler(_:), setOnTapHandler(_:), setOnUpdateHandler(_:), setVelocity(x:y:), sevenSynth, shake(duration:), shape:color:, shape:color:gradientColor:name:, shuffle(), shuffled(), sign, simSationalSmile, size, somethingBad1, somethingBad2, somethingBad3, somethingBad4, somethingGood1, somethingGood2, somethingGood3, somethingGood4, somethingGood5, somethingGood6, somethingGood7, sort(), sort(by:), sorted(), sorted(by:), southAMPitches, speak(_:voice:), speed(by:duration:), speed(to:duration:), spin(period:), splat1, split(separator:), spring1, spring2, spring3, spring4, springExtend, spriteA, spriteB, squarePoints(width:count:), squareRoot(), star(radius:points:sharpness:), start(), startIndex, starts(with:), stop(), stopSpeaking(), stopTones(), strangeWobble, string(fractionDigits:), subtract(_:), swapAt(_:_:), switch1, switch2, text, text:, text:color:, text:color:font:size:name:, textColor, throwSwitchLeft, throwSwitchRight, thud, tone, top, touchHandler, tree1Idle, tree2Idle, true, truncatingRemainder(dividingBy:), tubeHit1, tubeHit2, tubeHit3, type:, type:name:, type:text:name:, unhide(), union(_:), update(with:), updateValue(_:forKey:), uppercased(), values, verticalGravity, victory1, victory2, victory3, victory4, volume, wait(forDuration:), wait(forDuration:withRange:), walk, warble, warmBells, watchEverythingFall, width, width:height:, x, x:y:, x:y:duration:, xScale, y, yScale, {, {}, ||, }, ~=, Image, (with:), with:, uiImage)

import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true
//#-end-hidden-code
//#-editable-code
import UIKit

// Set up the scene.
let scene = Scene()
scene.backgroundImage = #imageLiteral(resourceName: "background3.png")
scene.hasCollisionBorder = true
let floor = Sprite(image: #imageLiteral(resourceName: "floor2"), columns: 20, rows: 1, name: "floor")
scene.place(floor, at: Point(x: 0, y: -475))
let titleLabel = Label(text: "SYNESTHESIA", color: .white, font: Font.SystemHeavyItalic, size: 70)
scene.place(titleLabel, at: Point(x: 0, y: 0))
titleLabel.fadeOut(after: 3)

// Create a rainbow of rectangles at the top of the scene, representing the color of light entering the camera.
for i in -5...5 {
    let hueValue = ((Double(i)) / 10) + 0.5
    let color = Color(hue: hueValue, saturation: 1, brightness: 1, alpha: 1)
    let rect = Graphic(shape: .rectangle(width: 100, height: 100, cornerRadius: 0), color: color)
    rect.alpha = 0.2
    scene.place(rect, at: Point(x: Double(i * 100), y: 450))
}

// Configure the graphic menu in the upper-right corner of the scene. Tap to choose a graphic from the menu and place it on the scene.
var placementImage: Image = #imageLiteral(resourceName: "bumper4.png")
let backgroundRect = Graphic(shape: .rectangle(width: 300, height: 75, cornerRadius: 20), color: .white)
backgroundRect.alpha = 0.5
let greenSelector = Graphic(image: #imageLiteral(resourceName: "bumper3.png"))
let pinkSelector = Graphic(image: #imageLiteral(resourceName: "bumper4.png"))
let springSelector = Graphic(image: #imageLiteral(resourceName: "springLoaded.png"))
scene.place(backgroundRect, at: Point(x: 300, y: 450))
scene.place(greenSelector, at: Point(x: 200, y: 450))
scene.place(pinkSelector, at: Point(x: 300, y: 450))
scene.place(springSelector, at: Point(x: 400, y: 450))
greenSelector.setOnTapHandler( { placementImage = #imageLiteral(resourceName: "bumper3.png") })
pinkSelector.setOnTapHandler( { placementImage = #imageLiteral(resourceName: "bumper4.png") })
springSelector.setOnTapHandler({ placementImage = #imageLiteral(resourceName: "springLoaded.png") })

// Use a dictionary to track the color of each ball placed on the scene.
var ballColors: [String:Double] = [:]
var ballCount = 1

// Use color information from lightSensor to create a ball every 0.5 seconds.
let lightSensor = LightSensor(configuration: .back)
var soundTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true, block: { _ in 
    let color = lightSensor.currentSample.hue
    let spriteLocationX = (color - 0.5) * 1000
    let ballName = "ball" + String(ballCount)
    let ball = Sprite(shape: Shape.circle(radius: 30), color: Color(hue: color, saturation: 1, brightness: 1, alpha: 1), gradientColor: #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0), name: ballName)
    ball.isAffectedByGravity = true
    scene.place(ball, at: Point(x: spriteLocationX, y: 450))
    
    // Store the ball’s color value in ballColors.
    ballCount += 1
    ballColors[ballName] = color
})

// Place one of three sprites on the scene, depending on the chosen placementImage.
var previousTouchPosition = Point(x: 0, y: 0)
scene.setOnFingerMovedHandler({ touch in 
    // Use the previous touch position to calculate the angle to place the sprite.
    let xDist = touch.position.x - previousTouchPosition.x
    let yDist = touch.position.y - previousTouchPosition.y
    let angle = atan(yDist/xDist) * 180 / pi
    
    var name = "pinkBumper"
    if placementImage == #imageLiteral(resourceName: "springLoaded.png") {
        name = "spring"
    } else if placementImage == #imageLiteral(resourceName: "bumper3.png") {
        name = "greenBumper"
    }
    let sprite = Sprite(image: placementImage, name: name)
    sprite.rotation = angle
    sprite.scale = 2.0
    sprite.isDynamic = false
    scene.place(sprite, at: touch.position)
    previousTouchPosition = touch.position
    // Remove the sprite when it’s tapped.
    sprite.setOnTapHandler( { 
        scene.remove(sprite)
    })
})

// Determine an instrument to play when sprites collide.
var canBeHit = true
scene.setOnCollisionHandler({ collision in 
    let names: [String] = [collision.spriteA.name, collision.spriteB.name]
    
    if names.contains(where: {
        $0.range(of: "ball") != nil
    }) {
        let ball = collision.spriteA.name.containsSubstring("ball") ? collision.spriteA : collision.spriteB
        var note = 1.0
        // Use the information from the ballColors dictionary to determine which note to play.
        if let ballHue = ballColors[ball.name] {
            note = ballHue * 23
        }
        if canBeHit {
            if names.contains("pinkBumper") {
                canBeHit = false
                playInstrument(Instrument.Kind.crystalSynth, note: note, volume: 80)
            } else if names.contains("greenBumper") {
                canBeHit = false
                playInstrument(Instrument.Kind.electricGuitar, note: note, volume: 75)
            } else if names.contains("spring") {
                canBeHit = false
                playInstrument(Instrument.Kind.bassSynth, note: note, volume: 100)
                let spring = collision.spriteA.name == "spring" ? collision.spriteA : collision.spriteB
                spring.runAnimation(.springExtend, timePerFrame: 0.2)
                ball.applyImpulse(x: collision.angle.dx * 350, y: collision.angle.dy * 350)
            }
            Timer.scheduledTimer(withTimeInterval: 0.2, repeats: false, block: { _ in
                canBeHit = true
            })
        }
        if names.contains("floor") {
            playInstrument(Instrument.Kind.sevenSynth, note: note, volume: 100)
            scene.remove(ball)
        }
    }
})
//#-end-editable-code
//#-hidden-code
//#-end-hidden-code
